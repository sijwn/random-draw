<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>럭키 박스 조 추첨 시스템 - 물리 엔진 강화판</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@900&display=swap');
        body { margin: 0; background: #050510; overflow: hidden; font-family: 'Noto Sans KR', sans-serif; }
        #intro-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.95); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 2000; transition: 0.8s;
        }
        #intro-btn {
            padding: 25px 65px; font-size: 2.2rem; cursor: pointer; border: none; border-radius: 100px;
            color: white; font-weight: bold; background: linear-gradient(45deg, #ff0055, #ff4d6d);
            box-shadow: 0 0 35px rgba(255, 0, 85, 0.5); transition: 0.3s;
        }
        #ui { position: absolute; top: 30px; width: 100%; text-align: center; z-index: 1000; pointer-events: none; opacity: 0; transition: 0.8s; }
        .btn-group { display: flex; justify-content: center; gap: 20px; pointer-events: auto; }
        button#draw-btn { padding: 15px 45px; font-size: 1.2rem; cursor: pointer; border: none; border-radius: 50px; color: white; font-weight: bold; background: linear-gradient(45deg, #00d2ff, #3a7bd5); }
        button:disabled { background: #444; cursor: not-allowed; opacity: 0.7; }
        #status-text { color: #fff; font-size: 2.2rem; text-shadow: 0 0 15px #00d2ff; margin-bottom: 15px; min-height: 50px; }
    </style>
</head>
<body>
    <div id="intro-layer">
        <div style="color: #00d2ff; font-size: 3.5rem; margin-bottom: 45px;">LUCKY DRAW</div>
        <button id="intro-btn" onclick="startEverything()">추첨 시작</button>
    </div>

    <div id="ui">
        <div id="status-text">추첨 준비</div>
        <div class="btn-group">
            <button id="draw-btn" onclick="handleDrawClick()">추첨</button>
        </div>
    </div>

    <script>
        const { Engine, Render, Runner, Bodies, Composite, Body, Events, Mouse, MouseConstraint, Vector } = Matter;
        
        // 물리 엔진 생성 및 설정
        const engine = Engine.create();
        engine.constraintIterations = 10; // 제약 조건 계산 정밀도 향상
        engine.positionIterations = 10;   // 위치 계산 정밀도 향상

        const render = Render.create({
            element: document.body, engine: engine,
            options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: 'transparent' }
        });

        const bgm = new Audio("quizbackground.mp3");
        bgm.loop = true; bgm.volume = 0.05; 
        const sfxTada = new Audio("tada.mp3");
        sfxTada.volume = 1.0; 
        const sfxSuccess = new Audio("https://actions.google.com/sounds/v1/cartoon/clink_clank.ogg");
        sfxSuccess.volume = 1.0;

        const groupsData = {
            1: ["공원태", "강하늘", "강윤아", "이사랑", "남하준", "박소담", "박소윤"].sort(() => Math.random() - 0.5),
            2: ["김온유", "신수연", "김하윤", "장지우", "장수연", "강로이", "이민아"].sort(() => Math.random() - 0.5),
            3: ["이건우", "장주하", "정유석", "남하은", "강하람", "허태민"].sort(() => Math.random() - 0.5)
        };

        let nextGroupToDraw = 1;
        let balls = [];
        let selectedBall = null;
        let lastPendingBall = null;
        let animProgress = 0;
        let isTurboMode = false;
        let isEnded = false; 
        let wallParts = []; 

        const centerX = window.innerWidth / 2;
        const centerY = 240;
        let groupX = [window.innerWidth * 0.2, window.innerWidth * 0.5, window.innerWidth * 0.8];
        let bucketBaseY = window.innerHeight - 75; 
        let groupCounters = [0, 0, 0];

        function getRemainingCount() {
            return groupsData[1].length + groupsData[2].length + groupsData[3].length;
        }

        function buildWalls() {
            wallParts = [];
            // 더 조밀하고 두꺼운 벽 생성 (80개 파츠, 두께 200px)
            for(let i=0; i<80; i++){
                const angle = (Math.PI*2/80)*i;
                const wall = Bodies.rectangle(
                    centerX + Math.cos(angle)*205, // 반지름 약간 조정
                    centerY + Math.sin(angle)*205, 
                    100, 300, // 두께를 300으로 대폭 상향 (벽을 뚫기 불가능하게 함)
                    { isStatic: true, angle: angle + Math.PI/2, render: { visible: false }, friction: 0 }
                );
                wallParts.push(wall);
                
                // 시각적 라인 (얇게 유지)
                if(i % 2 === 0) {
                    const guide = Bodies.rectangle(centerX + Math.cos(angle)*200, centerY + Math.sin(angle)*200, 3, 30, { isStatic: true, angle: angle + Math.PI/2, render: { fillStyle: '#00d2ff' }});
                    wallParts.push(guide);
                }
            }
            Composite.add(engine.world, wallParts);
        }

        function startEverything() {
            bgm.play();
            document.getElementById('intro-layer').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('intro-layer').style.display = 'none';
                document.getElementById('ui').style.opacity = '1';
            }, 800);

            const allNames = [...groupsData[1], ...groupsData[2], ...groupsData[3]];
            balls = allNames.map(name => {
                let gNum = 0;
                for(let g in groupsData) if(groupsData[g].includes(name)) gNum = parseInt(g);
                const b = Bodies.circle(centerX, centerY, 22, { 
                    restitution: 0.9, // 반발력 아주 약간 하향 (안정성)
                    friction: 0.001, 
                    render: { fillStyle: '#ffffff' }, 
                    label: name 
                });
                b.targetGroup = gNum;
                Body.setVelocity(b, { x: (Math.random()-0.5)*10, y: (Math.random()-0.5)*10 }); 
                return b;
            });
            Composite.add(engine.world, balls);
            buildWalls();
        }

        function handleDrawClick() {
            if (selectedBall || getRemainingCount() === 0) return;
            document.getElementById('draw-btn').disabled = true;
            document.getElementById('status-text').innerText = "섞는 중...";
            sfxTada.currentTime = 0;
            sfxTada.play(); 
            isTurboMode = true; 

            setTimeout(() => {
                isTurboMode = false;
                drawPhase();
            }, 1700);
        }

        function drawPhase() {
            let remaining = getRemainingCount();
            if(remaining === 2) {
                const targetIdx = groupsData[nextGroupToDraw].length > 0 ? nextGroupToDraw : (nextGroupToDraw % 3) + 1;
                const targetName = groupsData[targetIdx].shift();
                selectedBall = balls.find(b => b.label === targetName);
                const lastGroupIdx = groupsData[1].length > 0 ? 1 : (groupsData[2].length > 0 ? 2 : 3);
                const lastName = groupsData[lastGroupIdx].shift();
                lastPendingBall = balls.find(b => b.label === lastName);
            } else {
                let attempts = 0;
                while (groupsData[nextGroupToDraw].length === 0 && attempts < 3) {
                    nextGroupToDraw = (nextGroupToDraw % 3) + 1;
                    attempts++;
                }
                const targetName = groupsData[nextGroupToDraw].shift();
                selectedBall = balls.find(b => b.label === targetName);
            }
            document.getElementById('status-text').innerText = `${selectedBall.label} - ${selectedBall.targetGroup}조 당첨!`;
            animProgress = 0;
            selectedBall.startPos = { x: selectedBall.position.x, y: selectedBall.position.y };
            Body.setStatic(selectedBall, true);
            nextGroupToDraw = (nextGroupToDraw % 3) + 1;
        }

        function placeBall() {
            sfxTada.pause(); sfxTada.currentTime = 0;
            sfxSuccess.play();
            moveBallToBucket(selectedBall);
            selectedBall.isHighlighted = false;
            selectedBall = null;
            if (lastPendingBall) {
                moveBallToBucket(lastPendingBall);
                lastPendingBall = null;
            }
            if (getRemainingCount() === 0) startEnding();
            else {
                document.getElementById('status-text').innerText = "추첨 준비";
                document.getElementById('draw-btn').disabled = false;
            }
        }

        function moveBallToBucket(ball) {
            const gIdx = ball.targetGroup - 1;
            const count = groupCounters[gIdx];
            const col = count % 2;
            const row = Math.floor(count / 2);
            Body.setPosition(ball, { x: groupX[gIdx] + (col === 0 ? -34 : 34), y: bucketBaseY - (row * 50) - 25 });
            Body.setStatic(ball, true);
            groupCounters[gIdx]++;
        }

        function startEnding() {
            isEnded = true;
            document.getElementById('status-text').innerText = "추첨 완료! 결과를 확인하세요.";
            document.getElementById('draw-btn').innerText = "추첨 완료!";
            document.getElementById('draw-btn').disabled = true;
            wallParts.forEach(p => Composite.remove(engine.world, p));
            const targetY = window.innerHeight / 2 + 130; 
            const targetX = [window.innerWidth * 0.22, window.innerWidth * 0.5, window.innerWidth * 0.78];
            let moveProgress = 0;
            const originalGroupX = [...groupX];
            const originalBucketY = bucketBaseY;
            const moveInterval = setInterval(() => {
                moveProgress += 0.02;
                if(moveProgress >= 1) { clearInterval(moveInterval); return; }
                groupX = originalGroupX.map((ox, i) => ox + (targetX[i] - ox) * moveProgress);
                bucketBaseY = originalBucketY + (targetY - originalBucketY) * moveProgress;
                balls.forEach(b => {
                    const gIdx = b.targetGroup - 1;
                    const bList = balls.filter(v => v.targetGroup === b.targetGroup);
                    const bCount = bList.indexOf(b);
                    const col = bCount % 2; const row = Math.floor(bCount / 2);
                    const spacing = 65; 
                    Body.setPosition(b, { x: groupX[gIdx] + (col === 0 ? -45 : 45), y: bucketBaseY - (row * spacing + 35) });
                });
            }, 20);
        }

        Events.on(engine, 'beforeUpdate', () => {
            if (selectedBall && animProgress < 1) {
                animProgress += 0.025;
                const lerpX = selectedBall.startPos.x + (centerX - selectedBall.startPos.x) * animProgress;
                const lerpY = selectedBall.startPos.y + (centerY - selectedBall.startPos.y) * animProgress;
                Body.setPosition(selectedBall, { x: lerpX, y: lerpY });
                selectedBall.isHighlighted = true;
            }
            if(!isEnded) {
                balls.forEach(b => {
                    if(!b.isStatic && !b.isHighlighted && b !== lastPendingBall) {
                        const forceMag = isTurboMode ? 0.08 : 0.025; 
                        Body.applyForce(b, b.position, { x: (Math.random()-0.5)*forceMag, y: (Math.random()-0.5)*forceMag });
                        
                        // 강력한 경계 탈출 방지 로직
                        const dist = Vector.magnitude(Vector.sub(b.position, {x: centerX, y: centerY}));
                        if(dist > 180) {
                            const normal = Vector.normalise(Vector.sub({x: centerX, y: centerY}, b.position));
                            const speed = Vector.magnitude(b.velocity);
                            Body.setVelocity(b, Vector.mult(normal, speed > 5 ? 5 : speed));
                            Body.setPosition(b, Vector.add({x: centerX, y: centerY}, Vector.mult(Vector.neg(normal), 178)));
                        }
                    }
                });
            }
        });

        Events.on(render, 'afterRender', () => {
            const ctx = render.context;
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            const ballRadius = isEnded ? 22 * 1.5 : 22;
            balls.forEach(b => {
                if (!b.isHighlighted) {
                    ctx.beginPath(); ctx.arc(b.position.x, b.position.y, ballRadius, 0, Math.PI * 2);
                    ctx.fillStyle = "white"; ctx.fill(); ctx.strokeStyle = "#ccc"; ctx.lineWidth = 1; ctx.stroke();
                    ctx.fillStyle = "black";
                    ctx.font = isEnded ? "bold 18px Noto Sans KR" : "bold 13px Noto Sans KR";
                    ctx.fillText(b.label, b.position.x, b.position.y);
                }
            });
            if (selectedBall) {
                const currentRadius = 22 + (animProgress * 58);
                ctx.save(); ctx.translate(selectedBall.position.x, selectedBall.position.y);
                ctx.beginPath(); ctx.arc(0, 0, currentRadius, 0, Math.PI*2);
                ctx.fillStyle = "#ff0055"; ctx.fill(); ctx.strokeStyle = "#fff"; ctx.lineWidth = 4; ctx.stroke();
                ctx.fillStyle = "white"; ctx.font = `bold ${14 + (animProgress * 20)}px Noto Sans KR`;
                ctx.fillText(selectedBall.label, 0, 0); ctx.restore();
            }
            const lineScale = isEnded ? 1.5 : 1;
            groupX.forEach((x, i) => {
                ctx.fillStyle = "#00d2ff"; ctx.fillRect(x - 100 * lineScale, bucketBaseY + 10, 200 * lineScale, 10);
                ctx.fillStyle = "#ffffff"; ctx.font = `bold ${26 * lineScale}px Noto Sans KR`;
                ctx.fillText(`${i+1}조`, x, bucketBaseY + 50 * lineScale);
            });
        });

        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, { mouse: mouse });
        Events.on(mouseConstraint, 'mousedown', (event) => {
            const mousePos = event.mouse.position;
            if (selectedBall && animProgress >= 1) {
                const dx = mousePos.x - selectedBall.position.x;
                const dy = mousePos.y - selectedBall.position.y;
                if (Math.sqrt(dx * dx + dy * dy) <= 80) placeBall();
            }
        });

        // ⭐ 물리 엔진 업데이트 속도(Runner) 제어: 60fps 기준 substeps 적용
        const runner = Runner.create();
        Events.on(runner, "beforeTick", () => {
            // 엔진 업데이트를 한 번의 틱에 여러 번 수행하여 계산 정밀도 향상
            for (let i = 0; i < 6; i++) {
                Engine.update(engine, 1000 / 60 / 6);
            }
        });
        Runner.run(runner, engine);
        Render.run(render);
    </script>
</body>
</html>
