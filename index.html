<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>광주신성교회 겨울 캠프 조 추첨</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@900&display=swap');
        body { margin: 0; background: #050510; overflow: hidden; font-family: 'Noto Sans KR', sans-serif; }
        #intro-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.95); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 2000; transition: 0.8s;
        }
        #intro-btn {
            padding: 25px 65px; font-size: 2.2rem; cursor: pointer; border: none; border-radius: 100px;
            color: white; font-weight: bold; background: linear-gradient(45deg, #ff0055, #ff4d6d);
            box-shadow: 0 0 35px rgba(255, 0, 85, 0.5); transition: 0.3s;
        }
        #ui { position: absolute; top: 30px; width: 100%; text-align: center; z-index: 1000; pointer-events: none; opacity: 0; transition: 0.8s; }
        .btn-group { display: flex; justify-content: center; gap: 20px; pointer-events: auto; }
        button#draw-btn { padding: 15px 45px; font-size: 1.2rem; cursor: pointer; border: none; border-radius: 50px; color: white; font-weight: bold; background: linear-gradient(45deg, #00d2ff, #3a7bd5); }
        button:disabled { background: #444; cursor: not-allowed; opacity: 0.7; }
        #status-text { color: #fff; font-size: 2.2rem; text-shadow: 0 0 15px #00d2ff; margin-bottom: 15px; min-height: 50px; }
    </style>
</head>
<body>
    <div id="intro-layer">
        <div style="color: #00d2ff; font-size: 3rem; margin-bottom: 45px; text-align: center; line-height: 1.4;">
            광주신성교회<br>겨울 캠프 조 추첨
        </div>
        <button id="intro-btn" onclick="startEverything()">추첨 시작</button>
    </div>

    <div id="ui">
        <div id="status-text">추첨 준비</div>
        <div class="btn-group">
            <button id="draw-btn" onclick="handleDrawClick()">추첨</button>
        </div>
    </div>

    <script>
        const { Engine, Render, Runner, Bodies, Composite, Body, Events, Mouse, MouseConstraint } = Matter;
        const engine = Engine.create();
        const render = Render.create({
            element: document.body, engine: engine,
            options: { width: window.innerWidth, height: window.innerHeight, wireframes: false, background: 'transparent' }
        });

        const bgm = new Audio("quizbackground.mp3");
        bgm.loop = true; bgm.volume = 0.05; 
        const sfxTada = new Audio("tada.mp3");
        sfxTada.volume = 1.0; 
        const sfxSuccess = new Audio("https://actions.google.com/sounds/v1/cartoon/clink_clank.ogg");
        sfxSuccess.volume = 1.0;

        const groupsData = {
            1: ["공원태", "강하늘", "강윤아", "이사랑", "남하준", "박소담", "박소윤"].sort(() => Math.random() - 0.5),
            2: ["김온유", "신수연", "김하윤", "장지우", "장수연", "강로이", "이민아"].sort(() => Math.random() - 0.5),
            3: ["이건우", "장주하", "정유석", "남하은", "강하람", "허태민"].sort(() => Math.random() - 0.5)
        };

        let nextGroupToDraw = 1;
        let balls = [];
        let selectedBall = null;
        let animProgress = 0;
        let isTurboMode = false;
        let isEnded = false; 
        let wallParts = []; 

        const centerX = window.innerWidth / 2;
        const centerY = 240;
        let groupX = [window.innerWidth * 0.2, window.innerWidth * 0.5, window.innerWidth * 0.8];
        let bucketBaseY = window.innerHeight - 75; 
        let groupCounters = [0, 0, 0];

        function getRemainingCount() {
            return groupsData[1].length + groupsData[2].length + groupsData[3].length;
        }

        function startEverything() {
            bgm.play();
            document.getElementById('intro-layer').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('intro-layer').style.display = 'none';
                document.getElementById('ui').style.opacity = '1';
            }, 800);

            const allNames = [...groupsData[1], ...groupsData[2], ...groupsData[3]];
            balls = allNames.map(name => {
                let gNum = 0;
                for(let g in groupsData) if(groupsData[g].includes(name)) gNum = parseInt(g);
                const b = Bodies.circle(centerX, centerY, 22, { restitution: 0.95, friction: 0.001, render: { fillStyle: '#ffffff' }, label: name });
                b.targetGroup = gNum;
                Body.setVelocity(b, { x: (Math.random()-0.5)*7, y: (Math.random()-0.5)*7 }); 
                return b;
            });
            Composite.add(engine.world, balls);
            buildWalls();
        }

        function handleDrawClick() {
            if (selectedBall || getRemainingCount() === 0) return;
            document.getElementById('draw-btn').disabled = true;
            document.getElementById('status-text').innerText = "섞는 중...";
            sfxTada.currentTime = 0;
            sfxTada.play(); 
            isTurboMode = true; 

            setTimeout(() => {
                isTurboMode = false;
                drawPhase();
            }, 1400);
        }

        function drawPhase() {
            let attempts = 0;
            while (groupsData[nextGroupToDraw].length === 0 && attempts < 3) {
                nextGroupToDraw = (nextGroupToDraw % 3) + 1;
                attempts++;
            }

            const targetName = groupsData[nextGroupToDraw].shift();
            selectedBall = balls.find(b => b.label === targetName);

            document.getElementById('status-text').innerText = `${selectedBall.label} - ${selectedBall.targetGroup}조 당첨!`;
            animProgress = 0;
            selectedBall.startPos = { x: selectedBall.position.x, y: selectedBall.position.y };
            Body.setStatic(selectedBall, true);
            nextGroupToDraw = (nextGroupToDraw % 3) + 1;
        }

        function placeBall() {
            sfxTada.pause(); sfxTada.currentTime = 0;
            sfxSuccess.play();
            
            const groupIdx = selectedBall.targetGroup - 1;
            moveBallToBucket(selectedBall);
            selectedBall.isHighlighted = false;
            selectedBall = null;

            if (getRemainingCount() === 0) {
                startEnding();
            } else {
                document.getElementById('status-text').innerText = "추첨 준비";
                document.getElementById('draw-btn').disabled = false;
            }
        }

        function moveBallToBucket(ball) {
            const gIdx = ball.targetGroup - 1;
            const count = groupCounters[gIdx];
            const col = count % 2;
            const row = Math.floor(count / 2);
            
            Body.setPosition(ball, {
                x: groupX[gIdx] + (col === 0 ? -34 : 34),
                y: bucketBaseY - (row * 50) - 25
            });
            Body.setStatic(ball, true);
            groupCounters[gIdx]++;
        }

        function startEnding() {
            isEnded = true;
            document.getElementById('status-text').innerText = "추첨 완료! 결과를 확인하세요.";
            document.getElementById('draw-btn').innerText = "추첨 완료!";
            document.getElementById('draw-btn').disabled = true;

            wallParts.forEach(p => Composite.remove(engine.world, p));
            
            const targetY = window.innerHeight / 2 + 130; 
            const targetX = [window.innerWidth * 0.22, window.innerWidth * 0.5, window.innerWidth * 0.78];
            
            let moveProgress = 0;
            const originalGroupX = [...groupX];
            const originalBucketY = bucketBaseY;

            const moveInterval = setInterval(() => {
                moveProgress += 0.02;
                if(moveProgress >= 1) {
                    clearInterval(moveInterval);
                    return;
                }
                
                groupX = originalGroupX.map((ox, i) => ox + (targetX[i] - ox) * moveProgress);
                bucketBaseY = originalBucketY + (targetY - originalBucketY) * moveProgress;

                balls.forEach(b => {
                    const gIdx = b.targetGroup - 1;
                    const bList = balls.filter(v => v.targetGroup === b.targetGroup);
                    const bCount = bList.indexOf(b);
                    const col = bCount % 2;
                    const row = Math.floor(bCount / 2);
                    const spacing = 65; 
                    Body.setPosition(b, {
                        x: groupX[gIdx] + (col === 0 ? -45 : 45),
                        y: bucketBaseY - (row * spacing + 35)
                    });
                });
            }, 20);
        }

        Events.on(engine, 'beforeUpdate', () => {
            if (selectedBall && animProgress < 1) {
                animProgress += 0.025;
                const lerpX = selectedBall.startPos.x + (centerX - selectedBall.startPos.x) * animProgress;
                const lerpY = selectedBall.startPos.y + (centerY - selectedBall.startPos.y) * animProgress;
                Body.setPosition(selectedBall, { x: lerpX, y: lerpY });
                selectedBall.isHighlighted = true;
            }
            if(!isEnded) {
                balls.forEach(b => {
                    if(!b.isStatic && !b.isHighlighted) {
                        const forceMag = isTurboMode ? 0.06 : 0.02; 
                        Body.applyForce(b, b.position, { x: (Math.random()-0.5)*forceMag, y: (Math.random()-0.5)*forceMag });
                        const dist = Math.sqrt((b.position.x - centerX)**2 + (b.position.y - centerY)**2);
                        if(dist > 182) {
                            const angle = Math.atan2(centerY - b.position.y, centerX - b.position.x);
                            Body.setPosition(b, { x: centerX + Math.cos(angle)*175, y: centerY + Math.sin(angle)*175 });
                        }
                    }
                });
            }
        });

        Events.on(render, 'afterRender', () => {
            const ctx = render.context;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            const ballRadius = isEnded ? 22 * 1.5 : 22;

            balls.forEach(b => {
                if (!b.isHighlighted) {
                    ctx.beginPath();
                    ctx.arc(b.position.x, b.position.y, ballRadius, 0, Math.PI * 2);
                    ctx.fillStyle = "white";
                    ctx.fill();
                    ctx.strokeStyle = "#ccc"; ctx.lineWidth = 1; ctx.stroke();
                    ctx.fillStyle = "black";
                    ctx.font = isEnded ? "bold 18px Noto Sans KR" : "bold 13px Noto Sans KR";
                    ctx.fillText(b.label, b.position.x, b.position.y);
                }
            });

            if (selectedBall) {
                const currentRadius = 22 + (animProgress * 58);
                ctx.save();
                ctx.translate(selectedBall.position.x, selectedBall.position.y);
                ctx.beginPath(); ctx.arc(0, 0, currentRadius, 0, Math.PI*2);
                ctx.fillStyle = "#ff0055"; ctx.fill();
                ctx.strokeStyle = "#fff"; ctx.lineWidth = 4; ctx.stroke();
                ctx.fillStyle = "white"; ctx.font = `bold ${14 + (animProgress * 20)}px Noto Sans KR`;
                ctx.fillText(selectedBall.label, 0, 0);
                ctx.restore();
            }

            const lineScale = isEnded ? 1.5 : 1;
            groupX.forEach((x, i) => {
                ctx.fillStyle = "#00d2ff";
                ctx.fillRect(x - 100 * lineScale, bucketBaseY + 10, 200 * lineScale, 10);
                ctx.fillStyle = "#ffffff";
                ctx.font = `bold ${26 * lineScale}px Noto Sans KR`;
                ctx.fillText(`${i+1}조`, x, bucketBaseY + 50 * lineScale);
            });
        });

        function buildWalls() {
            wallParts = [];
            for(let i=0; i<40; i++){
                const angle = (Math.PI*2/40)*i;
                const wall = Bodies.rectangle(centerX + Math.cos(angle)*200, centerY + Math.sin(angle)*200, 60, 60, { isStatic: true, angle: angle + Math.PI/2, render: { visible: false }});
                wallParts.push(wall);
                const guide = Bodies.rectangle(centerX + Math.cos(angle)*200, centerY + Math.sin(angle)*200, 5, 40, { isStatic: true, angle: angle + Math.PI/2, render: { fillStyle: '#00d2ff' }});
                wallParts.push(guide);
            }
            Composite.add(engine.world, wallParts);
        }

        const mouse = Mouse.create(render.canvas);
        const mouseConstraint = MouseConstraint.create(engine, { mouse: mouse });
        Events.on(mouseConstraint, 'mousedown', (event) => {
            const mousePos = event.mouse.position;
            if (selectedBall && animProgress >= 1) {
                const dx = mousePos.x - selectedBall.position.x;
                const dy = mousePos.y - selectedBall.position.y;
                if (Math.sqrt(dx * dx + dy * dy) <= 80) placeBall();
            }
        });

        Runner.run(Runner.create(), engine);
        Render.run(render);
    </script>
</body>
</html>
